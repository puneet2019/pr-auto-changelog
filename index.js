const core = require('@actions/core');
const github = require('@actions/github');
const exec = require('@actions/exec');
const fs = require('fs');

// Constants for event types
const EVENT_TYPES = {
  PULL_REQUEST: 'pull_request'
};

// Constants for checkbox states
const CHECKBOX_STATES = {
  CHECKED: '[x] auto-generate changelog',
  UNCHECKED: '[ ] auto-generate changelog'
};

// Constants for dependabot
const DEPENDABOT_USER = 'dependabot[bot]';

// Constants for commit messages
const COMMIT_MESSAGES = {
  AUTO_CHANGELOG_PREFIX: '[AUTO-CHANGELOG]',
  UPDATE_TEMPLATE: '[AUTO-CHANGELOG] chore: update changelog with {count} new entries for PR #{prNumber}',
  REMOVE_TEMPLATE: '[AUTO-CHANGELOG] chore: remove auto-generated changelog entries for PR #{prNumber}'
};

// Constants for git configuration
const GIT_CONFIG = {
  USER_NAME: 'github-actions[bot]',
  USER_EMAIL: 'github-actions[bot]@users.noreply.github.com'
};

// Constants for changelog structure
const CHANGELOG_STRUCTURE = {
  HEADER: '# Changelog',
  UNRELEASED_SECTION: '## [Unreleased]',
  SECTION_PREFIX: '### ',
  ENTRY_PREFIX: '- ',
  PR_LINK_PATTERN: '[#{prNumber}]({prUrl})'
};

// Constants for changelog template
const CHANGELOG_TEMPLATE = `# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

`;

// Constants for output names
const OUTPUT_NAMES = {
  CHANGELOG_UPDATED: 'changelog-updated',
  CHANGES_ADDED: 'changes-added'
};

// Constants for output values
const OUTPUT_VALUES = {
  CHANGELOG_UPDATED_TRUE: 'true',
  CHANGELOG_UPDATED_FALSE: 'false',
  CHANGES_ADDED_ZERO: '0'
};



// Constants for entry types
const ENTRY_TYPES = {
  MANUAL: 'Manual',
  CONVENTIONAL: 'Conventional'
};

// Constants for default sections
const DEFAULT_SECTIONS = {
  CHANGES: 'Changes'
};

// Conventional commit types mapping to changelog sections
const COMMIT_TYPE_MAPPING = {
  'feat': 'Features',
  'feature': 'Features', 
  'fix': 'Bug Fixes',
  'docs': 'Documentation',
  'style': 'Style',
  'refactor': 'Refactoring',
  'perf': 'Performance',
  'test': 'Tests',
  'chore': 'Chores',
  'ci': 'CI/CD',
  'build': 'Build',
  'revert': 'Reverts'
};

async function run() {
  try {
    // Get inputs
    const token = core.getInput('github-token');
    const changelogPath = core.getInput('changelog-path');
    const autoCategorize = core.getInput('auto-categorize') === 'true';
    const commentTrigger = core.getInput('comment-trigger');
    const skipDependabot = core.getInput('skip-dependabot') === 'true';

    const octokit = github.getOctokit(token);
    const context = github.context;

    core.info(`Event name: ${context.eventName}`);

    // Only run on pull request events
    if (context.eventName !== EVENT_TYPES.PULL_REQUEST) {
      core.info('Action only runs on pull request events');
      return;
    }

    const { owner, repo } = context.repo;
    const prNumber = context.payload.pull_request.number;

    // Get PR details
    const { data: pr } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: prNumber
    });

    // Check if we should skip dependabot PRs
    if (skipDependabot && pr.user.login === DEPENDABOT_USER) {
      core.info('Skipping dependabot PR');
      return;
    }

    // Check for auto-generate changelog checkbox in PR description
    // Default: skip (unchecked), Only include when explicitly checked
    const hasUncheckedCheckbox = pr.body && pr.body.includes(CHECKBOX_STATES.UNCHECKED);
    const hasCheckedCheckbox = pr.body && pr.body.includes(CHECKBOX_STATES.CHECKED);
    
    if (hasUncheckedCheckbox) {
      core.info('Skipping due to unchecked auto-generate changelog checkbox in PR description');
      // Remove auto-generated entries for this PR
      await removeAutoGeneratedEntries(changelogPath, prNumber);
      return;
    }
    
    // If checkbox is checked, include in changelog
    if (hasCheckedCheckbox) {
      core.info('Including in changelog due to checked auto-generate changelog checkbox');
    }

    let changelogEntries = [];

    // Check for changelog entry in PR description
    let changelogEntry = null;
    
    if (pr.body && pr.body.includes(commentTrigger)) {
      changelogEntry = parseChangelogComment(pr.body, commentTrigger, pr, prNumber);
    }
    
    if (changelogEntry) {
      changelogEntries.push(changelogEntry);
    } else if (autoCategorize) {
      // Fallback to PR title if no changelog entry in description
      const entry = parseConventionalCommit(pr.title, pr, prNumber);
      if (entry) {
        changelogEntries.push(entry);
      }
    }

          if (changelogEntries.length === 0) {
        core.info('No changelog entries to add');
        core.setOutput(OUTPUT_NAMES.CHANGELOG_UPDATED, OUTPUT_VALUES.CHANGELOG_UPDATED_FALSE);
        core.setOutput(OUTPUT_NAMES.CHANGES_ADDED, OUTPUT_VALUES.CHANGES_ADDED_ZERO);
        return;
      }

    // Update changelog
    if (changelogEntries.length > 0) {
      core.info(`Processing ${changelogEntries.length} changelog entries`);
      const updated = await updateChangelog(changelogPath, changelogEntries);
      
      if (updated) {
        core.info('Changelog updated successfully');
        
        // Only commit if checkbox is checked
        if (hasCheckedCheckbox) {
          await commitChanges(changelogPath, changelogEntries.length, prNumber);
        }
        
        core.setOutput(OUTPUT_NAMES.CHANGELOG_UPDATED, OUTPUT_VALUES.CHANGELOG_UPDATED_TRUE);
        core.setOutput(OUTPUT_NAMES.CHANGES_ADDED, changelogEntries.length.toString());
      } else {
        core.info('No changes needed - changelog is already up to date');
        core.setOutput(OUTPUT_NAMES.CHANGELOG_UPDATED, OUTPUT_VALUES.CHANGELOG_UPDATED_FALSE);
        core.setOutput(OUTPUT_NAMES.CHANGES_ADDED, OUTPUT_VALUES.CHANGES_ADDED_ZERO);
      }
    } else {
      core.info('No changelog entries to process');
      core.setOutput(OUTPUT_NAMES.CHANGELOG_UPDATED, OUTPUT_VALUES.CHANGELOG_UPDATED_FALSE);
      core.setOutput(OUTPUT_NAMES.CHANGES_ADDED, OUTPUT_VALUES.CHANGES_ADDED_ZERO);
    }

  } catch (error) {
    core.setFailed(error.message);
  }
}



function parseChangelogComment(comment, trigger, pr, prNumber) {
  const lines = comment.split('\n');
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    if (trimmedLine.startsWith(trigger)) {
      const description = trimmedLine.replace(trigger, '').trim();
      
      if (description) {
        // First, try to parse as conventional commit format
        const conventionalEntry = parseConventionalCommit(description, pr, prNumber);
        if (conventionalEntry) {
          return conventionalEntry;
        }
        
        // Fallback to manual entry
        return {
          type: ENTRY_TYPES.MANUAL,
          description: description,
          prNumber: prNumber,
          prUrl: pr.html_url,
          section: DEFAULT_SECTIONS.CHANGES // Default section for manual entries
        };
      }
    }
  }
  return null;
}

function parseConventionalCommit(title, pr, prNumber) {
  // Parse conventional commit format: type(scope): description
  const conventionalRegex = /^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?!?:\s*(.+)$/i;
  const match = title.match(conventionalRegex);
  
  if (match) {
    const [, type, scope, description] = match;
    const section = COMMIT_TYPE_MAPPING[type.toLowerCase()] || DEFAULT_SECTIONS.CHANGES;
    
    return {
      type: type,
      scope: scope ? scope.slice(1, -1) : null, // Remove parentheses
      description: description,
      prNumber: prNumber,
      prUrl: pr.html_url,
      section: section
    };
  }
  
  return null;
}

async function updateChangelog(changelogPath, entries) {
  try {
    let changelogContent = '';
    
    // Read existing changelog or create new one
    if (fs.existsSync(changelogPath)) {
      changelogContent = fs.readFileSync(changelogPath, 'utf8');
    } else {
      changelogContent = CHANGELOG_TEMPLATE;
    }

    // Group entries by section
    const entriesBySection = {};
    entries.forEach(entry => {
      if (!entriesBySection[entry.section]) {
        entriesBySection[entry.section] = [];
      }
      entriesBySection[entry.section].push(entry);
    });

    // Find or create Unreleased section
    let unreleasedIndex = changelogContent.indexOf(CHANGELOG_STRUCTURE.UNRELEASED_SECTION);
    if (unreleasedIndex === -1) {
      // Add Unreleased section after the header
      const headerEnd = changelogContent.indexOf('\n## ');
      if (headerEnd === -1) {
        changelogContent += '\n## [Unreleased]\n\n';
        unreleasedIndex = changelogContent.indexOf(CHANGELOG_STRUCTURE.UNRELEASED_SECTION);
      } else {
        changelogContent = changelogContent.slice(0, headerEnd) + 
                          '\n## [Unreleased]\n\n' + 
                          changelogContent.slice(headerEnd);
        unreleasedIndex = changelogContent.indexOf(CHANGELOG_STRUCTURE.UNRELEASED_SECTION);
      }
    }

    // Find the end of the Unreleased section
    let nextSectionIndex = changelogContent.indexOf('\n## ', unreleasedIndex + 1);
    if (nextSectionIndex === -1) {
      nextSectionIndex = changelogContent.length;
    }

    let unreleasedContent = changelogContent.slice(unreleasedIndex, nextSectionIndex);
    const restContent = changelogContent.slice(nextSectionIndex);

    // First, remove any existing entries for the PRs we're updating
    entries.forEach(entry => {
      const prNumber = entry.prNumber;
      const lines = unreleasedContent.split('\n');
      let updatedLines = [];
      let entryRemoved = false;
      
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith(CHANGELOG_STRUCTURE.ENTRY_PREFIX)) {
          const entryText = trimmedLine.replace(/^- /, '');
          // Remove entries that contain this PR number
          if (entryText.includes(`[#${prNumber}]`)) {
            entryRemoved = true;
            continue; // Skip this line (remove the entry)
          }
        }
        updatedLines.push(line);
      }
      
      if (entryRemoved) {
        unreleasedContent = updatedLines.join('\n');
      }
    });

    // Add new entries to appropriate sections
    Object.keys(entriesBySection).forEach(sectionName => {
      let sectionIndex = unreleasedContent.indexOf(`### ${sectionName}`);
      
      if (sectionIndex === -1) {
        // Add new section
        const sectionHeader = `\n### ${sectionName}\n\n`;
        unreleasedContent += sectionHeader;
        sectionIndex = unreleasedContent.indexOf(`### ${sectionName}`);
      }

      // Find end of this section
      let sectionEndIndex = unreleasedContent.indexOf('\n### ', sectionIndex + 1);
      if (sectionEndIndex === -1) {
        sectionEndIndex = unreleasedContent.length;
      }

      // Create new entries for this section
      const sectionEntries = entriesBySection[sectionName];
      const newEntries = [];
      
      sectionEntries.forEach(entry => {
        const scopeText = entry.scope ? `**${entry.scope}**: ` : '';
        const newEntryText = `${scopeText}${entry.description} ([#${entry.prNumber}](${entry.prUrl}))`;
        const newEntryLine = `${CHANGELOG_STRUCTURE.ENTRY_PREFIX}${newEntryText}`;
        newEntries.push(newEntryLine);
      });

      if (newEntries.length > 0) {
        const newEntriesText = newEntries.join('\n') + '\n';
        
        unreleasedContent = unreleasedContent.slice(0, sectionEndIndex) + 
                            newEntriesText + 
                            unreleasedContent.slice(sectionEndIndex);
      }
    });

    // Reconstruct full changelog
    const newChangelogContent = changelogContent.slice(0, unreleasedIndex) + 
                                unreleasedContent + 
                                restContent;

    // Check if content actually changed
    if (changelogContent === newChangelogContent) {
      return false; // No changes made
    }

    // Write updated changelog
    fs.writeFileSync(changelogPath, newChangelogContent);
    
    return true;
  } catch (error) {
    core.error(`Failed to update changelog: ${error.message}`);
    return false;
  }
}





async function removeAutoGeneratedEntries(changelogPath, prNumber) {
  try {
    if (!fs.existsSync(changelogPath)) {
      return; // No changelog file to remove from
    }
    
    const changelogContent = fs.readFileSync(changelogPath, 'utf8');
    const lines = changelogContent.split('\n');
    let updatedContent = '';
    let entryRemoved = false;

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith(CHANGELOG_STRUCTURE.ENTRY_PREFIX)) {
        const entryText = trimmedLine.replace(/^- /, '');
        // Only remove entries that contain the PR number (auto-generated ones)
        if (entryText.includes(`[#${prNumber}]`)) {
          entryRemoved = true;
          continue; // Skip this line (remove the entry)
        }
      }
      updatedContent += line + '\n';
    }

    if (entryRemoved) {
      fs.writeFileSync(changelogPath, updatedContent.trim());
      core.info(`Auto-generated entry for PR #${prNumber} removed from changelog`);
      
      // Commit the removal with the same identifiable format
      await commitChanges(changelogPath, 0, prNumber);
    }
  } catch (error) {
    core.error(`Failed to remove auto-generated entry for PR #${prNumber}: ${error.message}`);
  }
}

async function commitChanges(changelogPath, entriesCount, prNumber) {
  try {
    // Configure git
    await exec.exec('git', ['config', 'user.name', GIT_CONFIG.USER_NAME]);
    await exec.exec('git', ['config', 'user.email', GIT_CONFIG.USER_EMAIL]);
    
    // Get the current branch name from the PR
    const context = github.context;
    const branchName = context.payload.pull_request.head.ref;
    
    // Checkout the PR branch if we're in detached HEAD
    try {
      await exec.exec('git', ['checkout', branchName]);
    } catch (error) {
      core.warning(`Could not checkout branch ${branchName}, trying to create it: ${error.message}`);
      // Try to create the branch if it doesn't exist
      await exec.exec('git', ['checkout', '-b', branchName]);
    }
    
    // Add and commit changes
    await exec.exec('git', ['add', changelogPath]);
    
    // Try to commit, but don't fail if there's nothing to commit
    try {
      const commitMessage = entriesCount > 0 
        ? COMMIT_MESSAGES.UPDATE_TEMPLATE.replace('{count}', entriesCount).replace('{prNumber}', prNumber)
        : COMMIT_MESSAGES.REMOVE_TEMPLATE.replace('{prNumber}', prNumber);
      
      await exec.exec('git', ['commit', '-m', commitMessage]);
    } catch (error) {
      if (error.message.includes('nothing to commit') || error.message.includes('no changes added to commit')) {
        core.info('No changes to commit - changelog is already up to date');
        return;
      }
      throw error;
    }
    
    // Push changes
    await exec.exec('git', ['push', 'origin', branchName]);
  } catch (error) {
    core.error(`Failed to commit changes: ${error.message}`);
    throw error;
  }
}

run();

// Export functions for testing
module.exports = {
  parseConventionalCommit,
  parseChangelogComment
};
